---
// Server-side authentication check and data fetching
import { requireAuth } from '../lib/auth-middleware';
import { db, Notification, eq, desc } from 'astro:db';
import BaseLayout from '../layouts/BaseLayout.astro';
import Header from '../components/Header.astro';
import ErrorMessage from '../components/ErrorMessage.astro';
import NotificationCard from '../components/NotificationCard.astro';
import NotificationsList from '../components/NotificationsList.astro';

// Check authentication
const username = requireAuth(Astro.cookies);
if (!username) {
  return Astro.redirect('/');
}

// Pagination settings
const ITEMS_PER_PAGE = 10;
const page = parseInt(Astro.url.searchParams.get('page') || '1');
const offset = (page - 1) * ITEMS_PER_PAGE;

// Fetch notifications from database with pagination
const notifications = await db
  .select()
  .from(Notification)
  .where(eq(Notification.username, username))
  .orderBy(desc(Notification.created_at))
  .limit(ITEMS_PER_PAGE)
  .offset(offset);

// Get total count for pagination
const allNotifications = await db
  .select()
  .from(Notification)
  .where(eq(Notification.username, username));

const totalCount = allNotifications.length;
const hasMore = totalCount > (page * ITEMS_PER_PAGE);

// Count unread notifications (from all, not just current page)
const unreadCount = allNotifications.filter(n => n.status === 'New').length;
---

<BaseLayout title="–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è - –°–í–£–ü">
  <Header />

  <!-- Toast notification -->
  <div id="toast" class="fixed top-20 right-4 bg-slate-800 text-white px-4 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-[9999] max-w-sm pointer-events-none">
    <div class="flex items-center gap-3">
      <span id="toastIcon" class="text-xl"></span>
      <span id="toastMessage" class="text-sm"></span>
    </div>
  </div>

  <!-- Main Content -->
  <main class="max-w-4xl mx-auto px-3 sm:px-4 py-4 sm:py-6">
    <ErrorMessage id="fcmError" type="warning" showRetry={false} />
    <ErrorMessage id="networkError" type="error" showRetry={true} />

    <NotificationsList 
      unreadCount={unreadCount}
      currentPage={page}
      totalCount={totalCount}
      itemsPerPage={ITEMS_PER_PAGE}
    >
      {notifications.length === 0 ? (
        <div class="bg-[#3A4556] rounded-2xl p-4 sm:p-6 text-center">
          <p class="text-slate-400 text-sm sm:text-base">–ù–µ–º–∞—î —Å–ø–æ–≤—ñ—â–µ–Ω—å</p>
        </div>
      ) : (
        notifications.map((notification) => (
          <NotificationCard
            id={notification.id}
            title={notification.notification_title}
            createdAt={notification.created_at}
            status={notification.status}
          />
        ))
      )}
    </NotificationsList>

    <!-- Pagination -->
    {hasMore && (
      <div class="mt-6 text-center">
        <a
          href={`/notifications?page=${page + 1}`}
          class="inline-block px-6 py-3 bg-[#4A5568] text-white text-sm font-medium rounded-lg hover:bg-[#5A6578] transition-colors"
        >
          –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —â–µ ({totalCount - (page * ITEMS_PER_PAGE)} –∑–∞–ª–∏—à–∏–ª–æ—Å—å)
        </a>
      </div>
    )}

    {page > 1 && (
      <div class="mt-4 text-center">
        <a
          href={`/notifications?page=${page - 1}`}
          class="inline-block px-4 py-2 text-slate-400 text-sm hover:text-white transition-colors"
        >
          ‚Üê –ù–∞–∑–∞–¥
        </a>
      </div>
    )}
  </main>

    <script>
      import { initializeApp } from 'firebase/app';
      import { getMessaging, getToken, onMessage } from 'firebase/messaging';

      // Firebase configuration
      const firebaseConfig = {
        apiKey: import.meta.env.PUBLIC_FIREBASE_API_KEY,
        authDomain: import.meta.env.PUBLIC_FIREBASE_AUTH_DOMAIN,
        projectId: import.meta.env.PUBLIC_FIREBASE_PROJECT_ID,
        storageBucket: import.meta.env.PUBLIC_FIREBASE_STORAGE_BUCKET,
        messagingSenderId: import.meta.env.PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
        appId: import.meta.env.PUBLIC_FIREBASE_APP_ID
      };

      const VAPID_KEY = import.meta.env.PUBLIC_FIREBASE_VAPID_KEY;

      // Register service worker for background notifications
      async function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js');
            console.log('Service Worker registered:', registration);
            return registration;
          } catch (error) {
            console.error('Service Worker registration failed:', error);
            return null;
          }
        }
        return null;
      }

      // Show FCM error message
      function showFCMError(message: string) {
        const fcmError = document.getElementById('fcmError');
        const fcmErrorText = document.getElementById('fcmErrorText');
        if (fcmError && fcmErrorText) {
          fcmErrorText.textContent = message;
          fcmError.classList.remove('hidden');
        }
      }

      // Hide FCM error message
      function hideFCMError() {
        const fcmError = document.getElementById('fcmError');
        if (fcmError) {
          fcmError.classList.add('hidden');
        }
      }

      // Show network error message
      function showNetworkError(message: string) {
        const networkError = document.getElementById('networkError');
        const networkErrorText = document.getElementById('networkErrorText');
        if (networkError && networkErrorText) {
          networkErrorText.textContent = message;
          networkError.classList.remove('hidden');
        }
      }

      // Hide network error message
      function hideNetworkError() {
        const networkError = document.getElementById('networkError');
        if (networkError) {
          networkError.classList.add('hidden');
        }
      }

      // Initialize Firebase and FCM
      async function initializeFCM() {
        try {
          // Register service worker first
          await registerServiceWorker();

          // Initialize Firebase app
          const app = initializeApp(firebaseConfig);
          const messaging = getMessaging(app);

          // Request notification permission
          const permission = await Notification.requestPermission();
          
          if (permission === 'granted') {
            console.log('Notification permission granted');
            hideFCMError();
            
            // Get FCM registration token
            const token = await getToken(messaging, { vapidKey: VAPID_KEY });
            
            if (token) {
              console.log('FCM Token retrieved:', token);
              
              // Register token with backend
              await registerFCMToken(token);
              
              // Set up foreground message handler
              onMessage(messaging, (payload) => {
                console.log('Foreground message received:', payload);
                
                // Add notification to UI
                if (payload.notification) {
                  addNotificationToUI({
                    title: payload.notification.body || '',
                    timestamp: new Date(),
                    status: 'New',
                    id: payload.data?.notificationId || Date.now()
                  });
                }
              });
            } else {
              console.error('No FCM token available');
              showFCMError('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ç–æ–∫–µ–Ω –¥–ª—è —Å–ø–æ–≤—ñ—â–µ–Ω—å. Push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –º–æ–∂—É—Ç—å –Ω–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏');
            }
          } else if (permission === 'denied') {
            console.info('‚ÑπÔ∏è Notification permission denied by user');
            showFCMError('üí° –î–æ–∑–≤—ñ–ª –Ω–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤—ñ–¥—Ö–∏–ª–µ–Ω–æ. –©–æ–± –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏ push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è, —É–≤—ñ–º–∫–Ω—ñ—Ç—å —ó—Ö —É –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö –±—Ä–∞—É–∑–µ—Ä–∞');
          } else {
            console.info('‚ÑπÔ∏è Notification permission not granted yet');
            showFCMError('üí° –î–æ–∑–≤—ñ–ª –Ω–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –Ω–µ –Ω–∞–¥–∞–Ω–æ. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å "–î–æ–∑–≤–æ–ª–∏—Ç–∏" —â–æ–± –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏ push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è');
          }
        } catch (error: any) {
          console.error('FCM initialization error:', error);
          
          // Provide specific error messages based on error type
          if (error.code === 'messaging/failed-service-worker-registration') {
            showFCMError('–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó Service Worker. –ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É');
          } else if (error.code === 'messaging/permission-blocked') {
            showFCMError('–î–æ–∑–≤—ñ–ª –Ω–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ. –£–≤—ñ–º–∫–Ω—ñ—Ç—å —ó—Ö —É –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö –±—Ä–∞—É–∑–µ—Ä–∞');
          } else if (error.code === 'messaging/unsupported-browser') {
            showFCMError('–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è');
          } else {
            showFCMError('–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó —Å–ø–æ–≤—ñ—â–µ–Ω—å. –°–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É');
          }
        }
      }

      // Register FCM token with backend using SSR (form submission)
      async function registerFCMToken(fcmToken: string) {
        try {
          console.log('Registering FCM token via SSR...');
          
          // Create form data
          const formData = new FormData();
          formData.append('fcm_token', fcmToken);

          // Submit to SSR endpoint (no timeout needed - server-side is fast)
          const response = await fetch('/register-fcm', {
            method: 'POST',
            body: formData
          });

          const data = await response.json();

          if (data.success) {
            console.log('‚úÖ FCM token registered successfully');
          } else {
            console.error('‚ùå FCM registration failed:', data.error);
          }
        } catch (error: any) {
          console.error('‚ö†Ô∏è Error registering FCM token:', error.message);
          // Don't show error to user - app will still work, just no push notifications
        }
      }

      // Update unread count in UI
      function updateUnreadCount() {
        const unreadCountElement = document.getElementById('unreadCount');
        if (unreadCountElement) {
          const unreadNotifications = document.querySelectorAll('.notification-item[data-status="New"]');
          unreadCountElement.textContent = String(unreadNotifications.length);
        }
      }

      // Add new notification to UI dynamically
      function addNotificationToUI(notification: { title: string; timestamp: Date; status: string; id: number | string }) {
        const notificationsList = document.getElementById('notificationsList');
        const markAllReadButton = document.getElementById('markAllReadButton') as HTMLButtonElement;
        
        if (!notificationsList) return;

        // Format timestamp
        const d = new Date(notification.timestamp);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = String(d.getFullYear()).slice(-2);
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        const formattedDate = `${day}.${month}.${year} ${hours}:${minutes}`;

        // Create notification element
        const notificationDiv = document.createElement('div');
        notificationDiv.className = 'notification-item bg-[#3A4556] rounded-2xl p-3 sm:p-4 hover:bg-[#4A5568] active:bg-[#4A5568] transition-colors cursor-pointer';
        notificationDiv.setAttribute('data-id', String(notification.id));
        notificationDiv.setAttribute('data-status', notification.status);
        
        notificationDiv.innerHTML = `
          <div class="flex items-start gap-2 sm:gap-3">
            ${notification.status === 'New' ? `
              <div class="flex-shrink-0 mt-1">
                <svg class="w-5 h-5 sm:w-6 sm:h-6 text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                </svg>
              </div>
            ` : ''}
            <div class="flex-1 min-w-0">
              <p class="text-white text-sm sm:text-base mb-1.5 sm:mb-2 break-words leading-relaxed">
                ${notification.title}
              </p>
              <p class="text-slate-400 text-xs sm:text-sm">
                ${formattedDate}
              </p>
            </div>
            ${notification.status === 'New' ? `
              <span class="notification-badge flex-shrink-0 px-2 sm:px-3 py-0.5 sm:py-1 bg-[#4A5568] text-white text-[10px] sm:text-xs font-medium rounded-lg">
                –ù–æ–≤–µ
              </span>
            ` : ''}
          </div>
        `;

        // Add click handler for marking as read
        notificationDiv.addEventListener('click', async () => {
          const id = notificationDiv.getAttribute('data-id');
          const status = notificationDiv.getAttribute('data-status');

          if (status === 'New' && id) {
            await markNotificationAsRead(notificationDiv, id);
          }
        });

        // Insert at the top of the list
        notificationsList.insertBefore(notificationDiv, notificationsList.firstChild);

        // Update unread count
        updateUnreadCount();

        // Enable "Mark all as read" button if there are new notifications
        if (markAllReadButton && notification.status === 'New') {
          markAllReadButton.disabled = false;
        }
      }

      // Retry button handler for network errors
      const retryNetworkButton = document.getElementById('retryNetworkButton');
      retryNetworkButton?.addEventListener('click', async () => {
        hideNetworkError();
        // Retry the last failed operation (mark all as read)
        await performMarkAllRead(true);
      });

      // Monitor online/offline status
      window.addEventListener('online', () => {
        hideNetworkError();
        console.log('Connection restored');
      });

      window.addEventListener('offline', () => {
        showNetworkError('–í—ñ–¥—Å—É—Ç–Ω—î —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è. –î–µ—è–∫—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –º–æ–∂—É—Ç—å –Ω–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏');
      });

      // Toast notification function
      function showToast(message: string, type: 'success' | 'error' | 'info' = 'info') {
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toastMessage');
        const toastIcon = document.getElementById('toastIcon');
        
        if (!toast || !toastMessage || !toastIcon) {
          console.error('Toast elements not found');
          return;
        }
        
        // Set icon and color based on type
        const config = {
          success: { icon: '‚úÖ', bg: 'bg-green-600' },
          error: { icon: '‚ùå', bg: 'bg-red-600' },
          info: { icon: '‚ÑπÔ∏è', bg: 'bg-blue-600' }
        };
        
        const { icon, bg } = config[type];
        toastIcon.textContent = icon;
        
        // Update background color
        toast.className = `fixed top-20 right-4 ${bg} text-white px-4 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-[9999] max-w-sm`;
        
        // Set message
        toastMessage.textContent = message;
        
        console.log('Showing toast:', message, type);
        
        // Show toast
        setTimeout(() => {
          toast.style.opacity = '1';
        }, 10);
        
        // Hide after 3 seconds
        setTimeout(() => {
          toast.style.opacity = '0';
        }, 3000);
      }

      // Initialize FCM on page load
      initializeFCM();

      // Update check functionality
      const updateCheckButton = document.getElementById('updateCheckButton');
      updateCheckButton?.addEventListener('click', async () => {
        try {
          if (!('serviceWorker' in navigator)) {
            showToast('Service Worker –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è', 'error');
            return;
          }

          // Disable button during check
          const button = updateCheckButton as HTMLButtonElement;
          button.disabled = true;
          button.style.opacity = '0.5';

          showToast('–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω—å...', 'info');

          // Get the service worker registration
          const registration = await navigator.serviceWorker.getRegistration();
          
          if (!registration) {
            showToast('Service Worker –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–æ', 'error');
            button.disabled = false;
            button.style.opacity = '1';
            return;
          }

          // Check for updates
          await registration.update();

          // Wait a bit for the update to be detected
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Check if there's a waiting service worker (new version available)
          if (registration.waiting) {
            showToast('–û–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ–¥–∞—Ç–∫—É...', 'success');
            // Automatically activate new version
            registration.waiting.postMessage({ type: 'SKIP_WAITING' });
            
            // Listen for the controller change (new SW activated)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              // Reload the page to use the new service worker
              window.location.reload();
            });
          } else if (registration.installing) {
            showToast('–û–Ω–æ–≤–ª–µ–Ω–Ω—è –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î—Ç—å—Å—è...', 'info');
            button.disabled = false;
            button.style.opacity = '1';
          } else {
            showToast('–î–æ–¥–∞—Ç–æ–∫ –≤–∂–µ –æ–Ω–æ–≤–ª–µ–Ω–æ', 'success');
            button.disabled = false;
            button.style.opacity = '1';
          }
        } catch (error) {
          console.error('Update check error:', error);
          showToast('–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –æ–Ω–æ–≤–ª–µ–Ω—å', 'error');
          const button = updateCheckButton as HTMLButtonElement;
          button.disabled = false;
          button.style.opacity = '1';
        }
      });

      // Mark all as read functionality with retry
      const markAllReadButton = document.getElementById('markAllReadButton') as HTMLButtonElement;
      let markAllRetryCount = 0;
      const MAX_MARK_ALL_RETRIES = 2;

      async function performMarkAllRead(isRetry: boolean = false) {
        try {
          const originalText = markAllReadButton.textContent;
          markAllReadButton.disabled = true;
          markAllReadButton.textContent = '–û–±—Ä–æ–±–∫–∞...';

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

          const response = await fetch('/mark-read', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ all: true }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            // Remove all "–ù–æ–≤–µ" badges and warning icons
            const badges = document.querySelectorAll('.notification-badge');
            badges.forEach(badge => badge.remove());
            
            const warningIcons = document.querySelectorAll('.notification-item svg.text-yellow-500');
            warningIcons.forEach(icon => icon.parentElement?.remove());

            // Update all notification statuses
            const items = document.querySelectorAll('.notification-item');
            items.forEach(item => {
              item.setAttribute('data-status', 'Read');
            });

            // Update unread count to 0
            updateUnreadCount();

            // Keep button disabled since all are now read
            markAllReadButton.textContent = '–í—Å—ñ –ø—Ä–æ—á–∏—Ç–∞–Ω—ñ';
            markAllRetryCount = 0;
            hideNetworkError();
          } else {
            throw new Error(`Server error: ${response.status}`);
          }
        } catch (error: any) {
          console.error('Mark all read error:', error);
          
          let errorMsg = '–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ–∑–Ω–∞—á–µ–Ω–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω—å';
          
          if (error.name === 'AbortError') {
            errorMsg = '–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤–∏—á–µ—Ä–ø–∞–Ω–æ';
          } else if (!navigator.onLine) {
            errorMsg = '–í—ñ–¥—Å—É—Ç–Ω—î —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è';
          }

          if (isRetry) {
            markAllRetryCount++;
          }

          if (markAllRetryCount < MAX_MARK_ALL_RETRIES) {
            showNetworkError(`${errorMsg}. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å "–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É" –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ—ó —Å–ø—Ä–æ–±–∏`);
          } else {
            showNetworkError(`${errorMsg}. –î–æ—Å—è–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ø—Ä–æ–±`);
          }

          markAllReadButton.disabled = false;
          markAllReadButton.textContent = '–í—Å—ñ –ø—Ä–æ—á–∏—Ç–∞–Ω—ñ';
        }
      }

      markAllReadButton?.addEventListener('click', async () => {
        await performMarkAllRead(false);
      });

      // Mark individual notification as read with retry
      async function markNotificationAsRead(item: Element, id: string, retryCount: number = 0): Promise<boolean> {
        const MAX_RETRIES = 2;
        
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout

          const response = await fetch('/mark-read', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id: parseInt(id) }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            // Remove the "–ù–æ–≤–µ" badge and warning icon
            const badge = item.querySelector('.notification-badge');
            badge?.remove();
            
            const warningIcon = item.querySelector('svg.text-yellow-500');
            warningIcon?.parentElement?.remove();

            // Update status
            item.setAttribute('data-status', 'Read');

            // Update unread count
            updateUnreadCount();

            // Check if all notifications are now read
            const remainingNew = document.querySelectorAll('.notification-item[data-status="New"]');
            if (remainingNew.length === 0 && markAllReadButton) {
              markAllReadButton.disabled = true;
            }

            hideNetworkError();
            return true;
          } else {
            throw new Error(`Server error: ${response.status}`);
          }
        } catch (error: any) {
          console.error('Mark read error:', error);
          
          if (retryCount < MAX_RETRIES) {
            // Automatically retry once
            console.log(`Retrying mark as read (attempt ${retryCount + 1}/${MAX_RETRIES})`);
            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retry
            return markNotificationAsRead(item, id, retryCount + 1);
          } else {
            // Show error after max retries
            let errorMsg = '–ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ–∑–Ω–∞—á–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —è–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–µ';
            
            if (error.name === 'AbortError') {
              errorMsg = '–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤–∏—á–µ—Ä–ø–∞–Ω–æ';
            } else if (!navigator.onLine) {
              errorMsg = '–í—ñ–¥—Å—É—Ç–Ω—î —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è';
            }
            
            showNetworkError(errorMsg);
            return false;
          }
        }
      }

      // Mark individual notification as read
      const notificationItems = document.querySelectorAll('.notification-item');
      notificationItems.forEach(item => {
        item.addEventListener('click', async () => {
          const id = item.getAttribute('data-id');
          const status = item.getAttribute('data-status');

          // Only mark as read if it's currently "New"
          if (status === 'New' && id) {
            await markNotificationAsRead(item, id);
          }
        });
      });
    </script>
</BaseLayout>
