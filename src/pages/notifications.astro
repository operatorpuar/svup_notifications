---
// Server-side authentication check and data fetching
import { requireAuth } from '../lib/auth-middleware';
import { db, Notification, eq, desc } from 'astro:db';
import BaseLayout from '../layouts/BaseLayout.astro';
import Header from '../components/Header.astro';
import ErrorMessage from '../components/ErrorMessage.astro';
import NotificationCard from '../components/NotificationCard.astro';
import NotificationsList from '../components/NotificationsList.astro';

// Check authentication
const username = requireAuth(Astro.cookies);
if (!username) {
  return Astro.redirect('/');
}

// Pagination settings
const ITEMS_PER_PAGE = 10;
const page = parseInt(Astro.url.searchParams.get('page') || '1');
const offset = (page - 1) * ITEMS_PER_PAGE;

// Fetch only NEW (unread) notifications from database with pagination
const notifications = await db
  .select()
  .from(Notification)
  .where(eq(Notification.username, username))
  .orderBy(desc(Notification.created_at))
  .limit(ITEMS_PER_PAGE)
  .offset(offset);

// Filter only unread notifications
const unreadNotifications = notifications.filter(n => n.status === 'New');

// Get total count of unread notifications for pagination
const allUnreadNotifications = await db
  .select()
  .from(Notification)
  .where(eq(Notification.username, username));

const allUnread = allUnreadNotifications.filter(n => n.status === 'New');
const totalCount = allUnread.length;
const hasMore = totalCount > (page * ITEMS_PER_PAGE);

// Count unread notifications
const unreadCount = totalCount;
---

<BaseLayout title="–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è - –°–í–£–ü">
  <Header />

  <!-- Toast notification -->
  <div id="toast" class="fixed top-20 right-4 bg-slate-800 text-white px-4 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-[9999] max-w-sm pointer-events-none">
    <div class="flex items-center gap-3">
      <span id="toastIcon" class="text-xl"></span>
      <span id="toastMessage" class="text-sm"></span>
    </div>
  </div>

  <!-- Main Content -->
  <main class="max-w-4xl mx-auto px-3 sm:px-4 py-4 sm:py-6">
    <ErrorMessage id="fcmError" type="warning" showRetry={false} />
    <ErrorMessage id="networkError" type="error" showRetry={true} />

    <NotificationsList 
      unreadCount={unreadCount}
      currentPage={page}
      totalCount={totalCount}
      itemsPerPage={ITEMS_PER_PAGE}
    >
      {unreadNotifications.length === 0 ? (
        <div class="bg-[#3A4556] rounded-2xl p-4 sm:p-6 text-center">
          <p class="text-slate-400 text-sm sm:text-base">–ù–µ–º–∞—î –Ω–æ–≤–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å</p>
        </div>
      ) : (
        unreadNotifications.map((notification) => (
          <NotificationCard
            id={notification.id}
            title={notification.notification_title}
            createdAt={notification.created_at}
            status={notification.status}
          />
        ))
      )}
    </NotificationsList>

    <!-- Pagination -->
    {hasMore && (
      <div class="mt-6 text-center">
        <a
          href={`/notifications?page=${page + 1}`}
          class="inline-block px-6 py-3 bg-[#4A5568] text-white text-sm font-medium rounded-lg hover:bg-[#5A6578] transition-colors"
        >
          –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —â–µ ({totalCount - (page * ITEMS_PER_PAGE)} –∑–∞–ª–∏—à–∏–ª–æ—Å—å)
        </a>
      </div>
    )}

    {page > 1 && (
      <div class="mt-4 text-center">
        <a
          href={`/notifications?page=${page - 1}`}
          class="inline-block px-4 py-2 text-slate-400 text-sm hover:text-white transition-colors"
        >
          ‚Üê –ù–∞–∑–∞–¥
        </a>
      </div>
    )}
  </main>

    <script>
      import { initializeApp } from 'firebase/app';
      import { getMessaging, getToken, onMessage } from 'firebase/messaging';

      // Firebase configuration
      const firebaseConfig = {
        apiKey: import.meta.env.PUBLIC_FIREBASE_API_KEY,
        authDomain: import.meta.env.PUBLIC_FIREBASE_AUTH_DOMAIN,
        projectId: import.meta.env.PUBLIC_FIREBASE_PROJECT_ID,
        storageBucket: import.meta.env.PUBLIC_FIREBASE_STORAGE_BUCKET,
        messagingSenderId: import.meta.env.PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
        appId: import.meta.env.PUBLIC_FIREBASE_APP_ID
      };

      const VAPID_KEY = import.meta.env.PUBLIC_FIREBASE_VAPID_KEY;

      // Register service worker for background notifications
      async function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js');
            console.log('Service Worker registered:', registration);
            return registration;
          } catch (error) {
            console.error('Service Worker registration failed:', error);
            return null;
          }
        }
        return null;
      }

      // Show FCM error message
      function showFCMError(message: string) {
        const fcmError = document.getElementById('fcmError');
        const fcmErrorText = document.getElementById('fcmErrorText');
        if (fcmError && fcmErrorText) {
          fcmErrorText.textContent = message;
          fcmError.classList.remove('hidden');
        }
      }

      // Hide FCM error message
      function hideFCMError() {
        const fcmError = document.getElementById('fcmError');
        if (fcmError) {
          fcmError.classList.add('hidden');
        }
      }

      // Show network error message
      function showNetworkError(message: string) {
        const networkError = document.getElementById('networkError');
        const networkErrorText = document.getElementById('networkErrorText');
        if (networkError && networkErrorText) {
          networkErrorText.textContent = message;
          networkError.classList.remove('hidden');
        }
      }

      // Hide network error message
      function hideNetworkError() {
        const networkError = document.getElementById('networkError');
        if (networkError) {
          networkError.classList.add('hidden');
        }
      }

      // Request notification permission (according to Firebase docs)
      async function requestNotificationPermission() {
        try {
          const permission = await Notification.requestPermission();
          if (permission === 'granted') {
            console.log('Notification permission granted');
            return true;
          } else {
            console.log('Notification permission denied');
            return false;
          }
        } catch (error) {
          console.error('Error requesting permission:', error);
          throw error;
        }
      }

      // Initialize Firebase and FCM
      async function initializeFCM() {
        try {
          // Register service worker first
          const registration = await registerServiceWorker();
          
          if (!registration) {
            showFCMError('Service Worker –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è –∞–±–æ –Ω–µ –≤–¥–∞–ª–æ—Å—è –∑–∞—Ä–µ—î—Å—Ç—Ä—É–≤–∞—Ç–∏');
            return;
          }

          // Initialize Firebase app
          const app = initializeApp(firebaseConfig);
          const messaging = getMessaging(app);

          // Request notification permission
          const permission = await Notification.requestPermission();
          
          if (permission === 'granted') {
            hideFCMError();
            
            // Get FCM registration token
            const token = await getToken(messaging, { vapidKey: VAPID_KEY });
            
            if (token) {
              // Register token with backend
              await registerFCMToken(token);
              
              // Handle incoming messages. Called when:
              // - a message is received while the app has focus
              // - the user clicks on an app notification created by a service worker
              onMessage(messaging, async (payload) => {
                console.log('[Foreground] Message received:', payload);
                
                // Extract notification data from payload
                const notificationTitle = payload.notification?.title || '–°–í–£–ü';
                const notificationBody = payload.notification?.body || payload.data?.notificationBody || '';
                const notificationId = payload.data?.notificationId;
                
                console.log('[Foreground] Extracted data:', { 
                  title: notificationTitle, 
                  body: notificationBody, 
                  notificationId 
                });
                
                // Save to database
                console.log('[Foreground] Saving notification to DB...');
                const saveResult = await saveNotificationToDB({
                  notification_title: notificationBody,
                  fcm_message_id: notificationId,
                  timestamp: new Date().toISOString()
                });
                
                // Add to UI immediately after successful save
                if (saveResult) {
                  console.log('[Foreground] Notification saved, adding to UI...');
                  
                  // Add notification to UI
                  addNotificationToUI({
                    id: saveResult.notification.id,
                    title: notificationBody,
                    timestamp: new Date(),
                    status: 'New'
                  });
                  
                  showToast('–ù–æ–≤–µ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –æ—Ç—Ä–∏–º–∞–Ω–æ!', 'success');
                } else {
                  console.warn('[Foreground] Save failed, stored in localStorage');
                  showToast('–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –æ—Ç—Ä–∏–º–∞–Ω–æ (–∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤—ñ–¥–∫–ª–∞–¥–µ–Ω–æ)', 'warning');
                }
              });
            } else {
              showFCMError('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —Ç–æ–∫–µ–Ω –¥–ª—è —Å–ø–æ–≤—ñ—â–µ–Ω—å. Push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –º–æ–∂—É—Ç—å –Ω–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏');
            }
          } else if (permission === 'denied') {
            showFCMError('üí° –î–æ–∑–≤—ñ–ª –Ω–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤—ñ–¥—Ö–∏–ª–µ–Ω–æ. –©–æ–± –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏ push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è, —É–≤—ñ–º–∫–Ω—ñ—Ç—å —ó—Ö —É –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö –±—Ä–∞—É–∑–µ—Ä–∞');
          } else {
            showFCMError('üí° –î–æ–∑–≤—ñ–ª –Ω–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –Ω–µ –Ω–∞–¥–∞–Ω–æ. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å "–î–æ–∑–≤–æ–ª–∏—Ç–∏" —â–æ–± –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏ push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è');
          }
          
        } catch (error: any) {
          console.error('FCM initialization error:', error.message);
          
          // Provide specific error messages based on error type
          if (error.code === 'messaging/failed-service-worker-registration') {
            showFCMError('–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó Service Worker. –ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É');
          } else if (error.code === 'messaging/permission-blocked') {
            showFCMError('–î–æ–∑–≤—ñ–ª –Ω–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ. –£–≤—ñ–º–∫–Ω—ñ—Ç—å —ó—Ö —É –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è—Ö –±—Ä–∞—É–∑–µ—Ä–∞');
          } else if (error.code === 'messaging/unsupported-browser') {
            showFCMError('–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î push-—Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è');
          } else if (error.code === 'messaging/token-subscribe-failed') {
            showFCMError('–ù–µ –≤–¥–∞–ª–æ—Å—è –ø—ñ–¥–ø–∏—Å–∞—Ç–∏—Å—è –Ω–∞ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è');
          } else {
            showFCMError('–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó —Å–ø–æ–≤—ñ—â–µ–Ω—å. –°–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É');
          }
        }
      }

      // Register FCM token with backend
      async function registerFCMToken(fcmToken: string) {
        try {
          const formData = new FormData();
          formData.append('fcm_token', fcmToken);

          const response = await fetch('/register-fcm', {
            method: 'POST',
            body: formData
          });

          const data = await response.json();

          if (!data.success) {
            console.error('FCM registration failed:', data.error);
          }
        } catch (error: any) {
          console.error('Error registering FCM token:', error.message);
          // Don't show error to user - app will still work, just no push notifications
        }
      }

      // Save notification to database with retry logic
      async function saveNotificationToDB(data: {
        notification_title: string;
        fcm_message_id?: string;
        timestamp?: string;
      }, retryCount: number = 0): Promise<any> {
        const MAX_RETRIES = 2;
        
        try {
          console.log(`Saving notification (attempt ${retryCount + 1}/${MAX_RETRIES + 1}):`, data);
          
          const response = await fetch('/api/notifications/save', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
          });

          console.log('Save response status:', response.status);

          if (!response.ok) {
            const errorText = await response.text();
            console.error('Save error response:', errorText);
            throw new Error(`Server error: ${response.status}`);
          }

          const result = await response.json();
          console.log('Save result:', result);

          if (result.success) {
            console.log('‚úÖ Notification saved successfully, ID:', result.notification?.id);
            return result; // Return the full result with notification data
          } else {
            throw new Error(result.error || 'Failed to save notification');
          }
        } catch (error: any) {
          console.error('Save error:', error.message);
          
          // Determine error type for better user feedback
          let errorType = 'unknown';
          if (error.message?.includes('Failed to fetch') || error.message?.includes('NetworkError')) {
            errorType = 'network';
          } else if (error.message?.includes('timeout')) {
            errorType = 'timeout';
          } else if (error.message?.includes('401')) {
            errorType = 'auth';
          }
          
          // Retry logic with 1 second delay
          if (retryCount < MAX_RETRIES) {
            console.log(`Retrying in 1 second... (attempt ${retryCount + 2}/${MAX_RETRIES + 1})`);
            await new Promise(resolve => setTimeout(resolve, 1000));
            return saveNotificationToDB(data, retryCount + 1);
          } else {
            console.warn('Max retries reached, storing in localStorage');
            // Store in localStorage as fallback after all retries failed
            storeFailedNotification(data);
            
            // Show appropriate error message to user
            if (errorType === 'network') {
              showToast('–ü–æ–º–∏–ª–∫–∞ –º–µ—Ä–µ–∂—ñ. –°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∑–±–µ—Ä–µ–∂–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ', 'warning');
            } else if (errorType === 'auth') {
              showToast('–ü–æ–º–∏–ª–∫–∞ –∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—ó. –ë—É–¥—å –ª–∞—Å–∫–∞, —É–≤—ñ–π–¥—ñ—Ç—å –∑–Ω–æ–≤—É', 'error');
            } else {
              showToast('–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏. –°–ø—Ä–æ–±—É—î–º–æ –ø—ñ–∑–Ω—ñ—à–µ', 'warning');
            }
            
            return null;
          }
        }
      }

      // Store failed notification in localStorage (Task 3.1)
      function storeFailedNotification(data: {
        notification_title: string;
        fcm_message_id?: string;
        timestamp?: string;
      }) {
        try {
          const pendingKey = 'pending_notifications';
          const existing = localStorage.getItem(pendingKey);
          const pending = existing ? JSON.parse(existing) : [];
          
          pending.push({
            ...data,
            failedAt: new Date().toISOString()
          });
          
          localStorage.setItem(pendingKey, JSON.stringify(pending));
          console.log('üì¶ Notification stored in localStorage for later retry');
        } catch (error) {
          console.error('Failed to store notification in localStorage:', error);
        }
      }

      // Open IndexedDB for reading pending notifications (Task 5)
      async function openIndexedDB(): Promise<IDBDatabase | null> {
        return new Promise((resolve, reject) => {
          try {
            const request = indexedDB.open('NotificationsDB', 1);
            
            request.onerror = () => {
              console.error('IndexedDB open error:', request.error);
              resolve(null);
            };
            
            request.onsuccess = () => {
              resolve(request.result);
            };
            
            request.onupgradeneeded = (event: any) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains('pending-notifications')) {
                db.createObjectStore('pending-notifications', { keyPath: 'id', autoIncrement: true });
              }
            };
          } catch (error) {
            console.error('IndexedDB error:', error);
            resolve(null);
          }
        });
      }

      // Get all pending notifications from IndexedDB (Task 5)
      async function getPendingFromIndexedDB(): Promise<any[]> {
        try {
          const db = await openIndexedDB();
          if (!db) {
            return [];
          }

          return new Promise((resolve, reject) => {
            try {
              const transaction = db.transaction(['pending-notifications'], 'readonly');
              const store = transaction.objectStore('pending-notifications');
              const request = store.getAll();

              request.onsuccess = () => {
                resolve(request.result || []);
              };

              request.onerror = () => {
                console.error('IndexedDB getAll error:', request.error);
                resolve([]);
              };
            } catch (error) {
              console.error('IndexedDB transaction error:', error);
              resolve([]);
            }
          });
        } catch (error) {
          console.error('Error getting pending from IndexedDB:', error);
          return [];
        }
      }

      // Remove notification from IndexedDB (Task 5)
      async function removeFromIndexedDB(id: number): Promise<boolean> {
        try {
          const db = await openIndexedDB();
          if (!db) {
            return false;
          }

          return new Promise((resolve) => {
            try {
              const transaction = db.transaction(['pending-notifications'], 'readwrite');
              const store = transaction.objectStore('pending-notifications');
              const request = store.delete(id);

              request.onsuccess = () => {
                resolve(true);
              };

              request.onerror = () => {
                console.error('IndexedDB delete error:', request.error);
                resolve(false);
              };
            } catch (error) {
              console.error('IndexedDB delete transaction error:', error);
              resolve(false);
            }
          });
        } catch (error) {
          console.error('Error removing from IndexedDB:', error);
          return false;
        }
      }

      // Retry pending notifications from localStorage and IndexedDB
      async function retryPendingNotifications() {
        try {
          let totalPending = 0;
          let totalSaved = 0;

          // Check localStorage for pending notifications
          const pendingKey = 'pending_notifications';
          const localStorageData = localStorage.getItem(pendingKey);
          let localStoragePending: any[] = [];
          
          if (localStorageData) {
            try {
              localStoragePending = JSON.parse(localStorageData);
              totalPending += localStoragePending.length;
            } catch (error) {
              console.error('Error parsing localStorage data:', error);
              localStorage.removeItem(pendingKey);
            }
          }

          // Check IndexedDB for pending notifications
          const indexedDBPending = await getPendingFromIndexedDB();
          totalPending += indexedDBPending.length;

          // Exit early if no pending notifications
          if (totalPending === 0) {
            return;
          }

          // Attempt to save all pending notifications from localStorage
          const successfulLocalStorageIndices: number[] = [];
          
          for (let i = 0; i < localStoragePending.length; i++) {
            const notification = localStoragePending[i];
            
            try {
              const success = await saveNotificationToDB({
                notification_title: notification.notification_title,
                fcm_message_id: notification.fcm_message_id,
                timestamp: notification.timestamp
              }, 0);

              if (success) {
                successfulLocalStorageIndices.push(i);
                totalSaved++;
              }
            } catch (error) {
              console.error('Error saving notification from localStorage:', error);
            }
          }

          // Remove successfully saved items from localStorage
          if (successfulLocalStorageIndices.length > 0) {
            const remaining = localStoragePending.filter((_: any, index: number) => 
              !successfulLocalStorageIndices.includes(index)
            );
            
            if (remaining.length === 0) {
              localStorage.removeItem(pendingKey);
            } else {
              localStorage.setItem(pendingKey, JSON.stringify(remaining));
            }
          }

          // Attempt to save all pending notifications from IndexedDB
          const successfulIndexedDBIds: number[] = [];
          
          for (const notification of indexedDBPending) {
            try {
              const success = await saveNotificationToDB({
                notification_title: notification.notification_title,
                fcm_message_id: notification.fcm_message_id,
                timestamp: notification.timestamp
              }, 0);

              if (success) {
                successfulIndexedDBIds.push(notification.id);
                totalSaved++;
              }
            } catch (error) {
              console.error('Error saving notification from IndexedDB:', error);
            }
          }

          // Remove successfully saved items from IndexedDB
          for (const id of successfulIndexedDBIds) {
            await removeFromIndexedDB(id);
          }

          // Refresh the notifications list if any were saved
          if (totalSaved > 0) {
            await fetchAndUpdateNotifications();
            showToast(`${totalSaved} –≤—ñ–¥–∫–ª–∞–¥–µ–Ω–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å –∑–±–µ—Ä–µ–∂–µ–Ω–æ`, 'success');
          }

        } catch (error: any) {
          console.error('Error in retryPendingNotifications:', error.message);
        }
      }

      // Update unread count in UI
      function updateUnreadCount() {
        const unreadCountElement = document.getElementById('unreadCount');
        if (unreadCountElement) {
          const unreadNotifications = document.querySelectorAll('.notification-item[data-status="New"]');
          unreadCountElement.textContent = String(unreadNotifications.length);
        }
      }

      // Fetch and update notifications from server
      async function fetchAndUpdateNotifications() {
        try {
          console.log('[UI Update] Fetching notifications from server...');
          const currentPage = new URLSearchParams(window.location.search).get('page') || '1';
          const response = await fetch(`/api/notifications/fetch?page=${currentPage}&limit=10`);
          
          if (!response.ok) {
            throw new Error(`Failed to fetch notifications: ${response.status}`);
          }

          const data = await response.json();
          console.log('[UI Update] Received data:', data);
          
          if (data.success) {
            // Update notifications list
            const notificationsList = document.getElementById('notificationsList');
            if (!notificationsList) {
              console.error('[UI Update] notificationsList element not found!');
              return;
            }

            console.log(`[UI Update] Updating UI with ${data.notifications.length} notifications`);

            // Clear current list
            notificationsList.innerHTML = '';

            // Add notifications
            if (data.notifications.length === 0) {
              notificationsList.innerHTML = `
                <div class="bg-[#3A4556] rounded-2xl p-4 sm:p-6 text-center">
                  <p class="text-slate-400 text-sm sm:text-base">–ù–µ–º–∞—î —Å–ø–æ–≤—ñ—â–µ–Ω—å</p>
                </div>
              `;
            } else {
              data.notifications.forEach((notification: any) => {
                console.log('[UI Update] Adding notification to UI:', notification.id);
                addNotificationToUI({
                  id: notification.id,
                  title: notification.notification_title,
                  timestamp: new Date(notification.created_at),
                  status: notification.status
                });
              });
            }

            // Update unread count
            const unreadCountElement = document.getElementById('unreadCount');
            if (unreadCountElement) {
              unreadCountElement.textContent = String(data.unreadCount);
              console.log('[UI Update] Updated unread count:', data.unreadCount);
            }

            // Update mark all button state
            const markAllReadButton = document.getElementById('markAllReadButton') as HTMLButtonElement;
            if (markAllReadButton) {
              markAllReadButton.disabled = data.unreadCount === 0;
            }
            
            console.log('[UI Update] ‚úÖ UI updated successfully');
          } else {
            throw new Error(data.error || 'Unknown error');
          }
        } catch (error: any) {
          console.error('[UI Update] ‚ùå Error fetching notifications:', error.message);
          
          // Determine error type for better user feedback
          if (error.message?.includes('Failed to fetch') || error.message?.includes('NetworkError')) {
            showToast('–ü–æ–º–∏–ª–∫–∞ –º–µ—Ä–µ–∂—ñ –ø—Ä–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω—å', 'error');
          } else if (error.message?.includes('timeout')) {
            showToast('–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤–∏—á–µ—Ä–ø–∞–Ω–æ', 'error');
          } else {
            showToast('–ü–æ–º–∏–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Å–ø–æ–≤—ñ—â–µ–Ω—å', 'error');
          }
        }
      }

      // Add new notification to UI dynamically
      function addNotificationToUI(notification: { title: string; timestamp: Date; status: string; id: number | string }) {
        const notificationsList = document.getElementById('notificationsList');
        const markAllReadButton = document.getElementById('markAllReadButton') as HTMLButtonElement;
        
        if (!notificationsList) return;

        // Remove "–ù–µ–º–∞—î –Ω–æ–≤–∏—Ö —Å–ø–æ–≤—ñ—â–µ–Ω—å" message if it exists
        const emptyState = notificationsList.querySelector('.bg-\\[\\#3A4556\\] p');
        if (emptyState && emptyState.textContent?.includes('–ù–µ–º–∞—î')) {
          emptyState.parentElement?.remove();
        }

        // Format timestamp
        const d = new Date(notification.timestamp);
        const day = String(d.getDate()).padStart(2, '0');
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const year = String(d.getFullYear()).slice(-2);
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        const formattedDate = `${day}.${month}.${year} ${hours}:${minutes}`;

        // Create notification element
        const notificationDiv = document.createElement('div');
        notificationDiv.className = 'notification-item bg-[#3A4556] rounded-2xl p-3 sm:p-4 hover:bg-[#4A5568] active:bg-[#4A5568] transition-colors cursor-pointer';
        notificationDiv.setAttribute('data-id', String(notification.id));
        notificationDiv.setAttribute('data-status', notification.status);
        
        notificationDiv.innerHTML = `
          <div class="flex items-start gap-2 sm:gap-3">
            ${notification.status === 'New' ? `
              <div class="flex-shrink-0 mt-1">
                <svg class="w-5 h-5 sm:w-6 sm:h-6 text-yellow-500" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                </svg>
              </div>
            ` : ''}
            <div class="flex-1 min-w-0">
              <p class="text-white text-sm sm:text-base mb-1.5 sm:mb-2 break-words leading-relaxed">
                ${notification.title}
              </p>
              <p class="text-slate-400 text-xs sm:text-sm">
                ${formattedDate}
              </p>
            </div>
            ${notification.status === 'New' ? `
              <span class="notification-badge flex-shrink-0 px-2 sm:px-3 py-0.5 sm:py-1 bg-[#4A5568] text-white text-[10px] sm:text-xs font-medium rounded-lg">
                –ù–æ–≤–µ
              </span>
            ` : ''}
          </div>
        `;

        // Add click handler for marking as read
        notificationDiv.addEventListener('click', async () => {
          const id = notificationDiv.getAttribute('data-id');
          const status = notificationDiv.getAttribute('data-status');

          if (status === 'New' && id) {
            await markNotificationAsRead(notificationDiv, id);
          }
        });

        // Insert at the top of the list
        notificationsList.insertBefore(notificationDiv, notificationsList.firstChild);

        // Update unread count
        updateUnreadCount();

        // Enable "Mark all as read" button if there are new notifications
        if (markAllReadButton && notification.status === 'New') {
          markAllReadButton.disabled = false;
        }
      }

      // Retry button handler for network errors
      const retryNetworkButton = document.getElementById('retryNetworkButton');
      retryNetworkButton?.addEventListener('click', async () => {
        hideNetworkError();
        // Retry the last failed operation (mark all as read)
        await performMarkAllRead(true);
      });

      // Monitor online/offline status
      window.addEventListener('online', () => {
        hideNetworkError();
        console.log('Connection restored');
      });

      window.addEventListener('offline', () => {
        showNetworkError('–í—ñ–¥—Å—É—Ç–Ω—î —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è. –î–µ—è–∫—ñ —Ñ—É–Ω–∫—Ü—ñ—ó –º–æ–∂—É—Ç—å –Ω–µ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏');
      });

      // Toast notification function
      function showToast(message: string, type: 'success' | 'error' | 'info' | 'warning' = 'info') {
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toastMessage');
        const toastIcon = document.getElementById('toastIcon');
        
        if (!toast || !toastMessage || !toastIcon) {
          return;
        }
        
        // Set icon and color based on type
        const config = {
          success: { icon: '‚úÖ', bg: 'bg-green-600' },
          error: { icon: '‚ùå', bg: 'bg-red-600' },
          info: { icon: '‚ÑπÔ∏è', bg: 'bg-blue-600' },
          warning: { icon: '‚ö†Ô∏è', bg: 'bg-yellow-600' }
        };
        
        const { icon, bg } = config[type];
        toastIcon.textContent = icon;
        
        // Update background color
        toast.className = `fixed top-20 right-4 ${bg} text-white px-4 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-[9999] max-w-sm`;
        
        // Set message
        toastMessage.textContent = message;
        
        // Show toast
        setTimeout(() => {
          toast.style.opacity = '1';
        }, 10);
        
        // Hide after duration based on type (errors stay longer)
        const duration = type === 'error' ? 5000 : type === 'warning' ? 4000 : 3000;
        setTimeout(() => {
          toast.style.opacity = '0';
        }, duration);
      }

      // Initialize FCM on page load
      initializeFCM();

      // Check for pending notifications in localStorage and retry (Task 3.3)
      retryPendingNotifications();

      // Reload page when it becomes visible after being hidden
      // This ensures background notifications are shown when user returns
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // Mark that page was hidden
          sessionStorage.setItem('pageWasHidden', 'true');
          console.log('[Visibility] Page hidden');
        } else {
          // Check if page was previously hidden
          const wasHidden = sessionStorage.getItem('pageWasHidden');
          if (wasHidden === 'true') {
            console.log('[Visibility] Page became visible after being hidden, reloading...');
            sessionStorage.removeItem('pageWasHidden');
            window.location.reload();
          }
        }
      });

      // Update check functionality
      const updateCheckButton = document.getElementById('updateCheckButton');
      updateCheckButton?.addEventListener('click', async () => {
        try {
          if (!('serviceWorker' in navigator)) {
            showToast('Service Worker –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î—Ç—å—Å—è', 'error');
            return;
          }

          // Disable button during check
          const button = updateCheckButton as HTMLButtonElement;
          button.disabled = true;
          button.style.opacity = '0.5';

          showToast('–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω—å...', 'info');

          // Get the service worker registration
          const registration = await navigator.serviceWorker.getRegistration();
          
          if (!registration) {
            showToast('Service Worker –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–æ', 'error');
            button.disabled = false;
            button.style.opacity = '1';
            return;
          }

          // Check for updates
          await registration.update();

          // Wait a bit for the update to be detected
          await new Promise(resolve => setTimeout(resolve, 1000));

          // Check if there's a waiting service worker (new version available)
          if (registration.waiting) {
            showToast('–û–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–æ–¥–∞—Ç–∫—É...', 'success');
            // Automatically activate new version
            registration.waiting.postMessage({ type: 'SKIP_WAITING' });
            
            // Listen for the controller change (new SW activated)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              // Reload the page to use the new service worker
              window.location.reload();
            });
          } else if (registration.installing) {
            showToast('–û–Ω–æ–≤–ª–µ–Ω–Ω—è –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î—Ç—å—Å—è...', 'info');
            button.disabled = false;
            button.style.opacity = '1';
          } else {
            showToast('–î–æ–¥–∞—Ç–æ–∫ –≤–∂–µ –æ–Ω–æ–≤–ª–µ–Ω–æ', 'success');
            button.disabled = false;
            button.style.opacity = '1';
          }
        } catch (error) {
          console.error('Update check error:', error);
          showToast('–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –æ–Ω–æ–≤–ª–µ–Ω—å', 'error');
          const button = updateCheckButton as HTMLButtonElement;
          button.disabled = false;
          button.style.opacity = '1';
        }
      });

      // Mark all as read functionality with retry
      const markAllReadButton = document.getElementById('markAllReadButton') as HTMLButtonElement;
      let markAllRetryCount = 0;
      const MAX_MARK_ALL_RETRIES = 2;

      async function performMarkAllRead(isRetry: boolean = false) {
        try {
          markAllReadButton.disabled = true;
          markAllReadButton.textContent = '–û–±—Ä–æ–±–∫–∞...';

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

          const response = await fetch('/mark-read', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ all: true }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            // Hide all notifications with fade out animation
            const items = document.querySelectorAll('.notification-item');
            items.forEach((item, index) => {
              const element = item as HTMLElement;
              element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
              element.style.transitionDelay = `${index * 0.05}s`; // Stagger animation
              element.style.opacity = '0';
              element.style.transform = 'translateX(20px)';
            });
            
            // Remove all items and show empty state after animation
            setTimeout(() => {
              items.forEach(item => item.remove());
              
              const notificationsList = document.getElementById('notificationsList');
              if (notificationsList) {
                notificationsList.innerHTML = `
                  <div class="bg-[#3A4556] rounded-2xl p-4 sm:p-6 text-center">
                    <p class="text-slate-400 text-sm sm:text-base">–ù–µ–º–∞—î —Å–ø–æ–≤—ñ—â–µ–Ω—å</p>
                  </div>
                `;
              }
            }, 300 + (items.length * 50));

            // Update unread count to 0
            updateUnreadCount();

            // Keep button disabled since all are now read
            markAllReadButton.textContent = '–í—Å—ñ –ø—Ä–æ—á–∏—Ç–∞–Ω—ñ';
            markAllRetryCount = 0;
            hideNetworkError();
          } else {
            throw new Error(`Server error: ${response.status}`);
          }
        } catch (error: any) {
          console.error('Mark all read error:', error);
          
          let errorMsg = '–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø–æ–∑–Ω–∞—á–µ–Ω–Ω—ñ —Å–ø–æ–≤—ñ—â–µ–Ω—å';
          
          if (error.name === 'AbortError') {
            errorMsg = '–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤–∏—á–µ—Ä–ø–∞–Ω–æ';
          } else if (!navigator.onLine) {
            errorMsg = '–í—ñ–¥—Å—É—Ç–Ω—î —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è';
          }

          if (isRetry) {
            markAllRetryCount++;
          }

          if (markAllRetryCount < MAX_MARK_ALL_RETRIES) {
            showNetworkError(`${errorMsg}. –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å "–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É" –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ—ó —Å–ø—Ä–æ–±–∏`);
          } else {
            showNetworkError(`${errorMsg}. –î–æ—Å—è–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ø—Ä–æ–±`);
          }

          markAllReadButton.disabled = false;
          markAllReadButton.textContent = '–í—Å—ñ –ø—Ä–æ—á–∏—Ç–∞–Ω—ñ';
        }
      }

      markAllReadButton?.addEventListener('click', async () => {
        await performMarkAllRead(false);
      });

      // Mark individual notification as read with retry
      async function markNotificationAsRead(item: Element, id: string, retryCount: number = 0): Promise<boolean> {
        const MAX_RETRIES = 2;
        
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 8000); // 8 second timeout

          const response = await fetch('/mark-read', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ id: parseInt(id) }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            // Update status to Read BEFORE hiding (so counter updates correctly)
            item.setAttribute('data-status', 'Read');
            
            // Update unread count immediately
            updateUnreadCount();
            
            // Hide notification with fade out animation
            item.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
            item.style.opacity = '0';
            item.style.transform = 'translateX(20px)';
            
            // Remove from DOM after animation
            setTimeout(() => {
              item.remove();
              
              // Check if list is now empty
              const notificationsList = document.getElementById('notificationsList');
              if (notificationsList && notificationsList.children.length === 0) {
                notificationsList.innerHTML = `
                  <div class="bg-[#3A4556] rounded-2xl p-4 sm:p-6 text-center">
                    <p class="text-slate-400 text-sm sm:text-base">–ù–µ–º–∞—î —Å–ø–æ–≤—ñ—â–µ–Ω—å</p>
                  </div>
                `;
              }
            }, 300);

            // Check if all notifications are now read
            const remainingNew = document.querySelectorAll('.notification-item[data-status="New"]');
            if (remainingNew.length === 0 && markAllReadButton) {
              markAllReadButton.disabled = true;
            }

            hideNetworkError();
            return true;
          } else {
            throw new Error(`Server error: ${response.status}`);
          }
        } catch (error: any) {
          console.error('Mark read error:', error);
          
          if (retryCount < MAX_RETRIES) {
            // Automatically retry once
            console.log(`Retrying mark as read (attempt ${retryCount + 1}/${MAX_RETRIES})`);
            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retry
            return markNotificationAsRead(item, id, retryCount + 1);
          } else {
            // Show error after max retries
            let errorMsg = '–ù–µ –≤–¥–∞–ª–æ—Å—è –ø–æ–∑–Ω–∞—á–∏—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è —è–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–µ';
            
            if (error.name === 'AbortError') {
              errorMsg = '–ß–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤–∏—á–µ—Ä–ø–∞–Ω–æ';
            } else if (!navigator.onLine) {
              errorMsg = '–í—ñ–¥—Å—É—Ç–Ω—î —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç-–∑\'—î–¥–Ω–∞–Ω–Ω—è';
            }
            
            showNetworkError(errorMsg);
            return false;
          }
        }
      }

      // Mark individual notification as read
      const notificationItems = document.querySelectorAll('.notification-item');
      notificationItems.forEach(item => {
        item.addEventListener('click', async () => {
          const id = item.getAttribute('data-id');
          const status = item.getAttribute('data-status');

          // Only mark as read if it's currently "New"
          if (status === 'New' && id) {
            await markNotificationAsRead(item, id);
          }
        });
      });
    </script>
</BaseLayout>
